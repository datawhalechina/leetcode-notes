# 04.04.02 习题解析（第 10 天）

## 1. [0455. 分发饼干](https://leetcode.cn/problems/assign-cookies/)

### 1.1 题目大意

**描述**：一位很棒的家长为孩子们分发饼干。对于每个孩子 `i`，都有一个胃口值 `g[i]`，即每个小孩希望得到饼干的最小尺寸值。对于每块饼干 `j`，都有一个尺寸值 `s[j]`。只有当 `s[j] > g[i]` 时，我们才能将饼干 `j` 分配给孩子 `i`。每个孩子最多只能给一块饼干。

现在给定代表所有孩子胃口值的数组 `g` 和代表所有饼干尺寸的数组 `j`。

**要求**：尽可能满足越多数量的孩子，并求出这个最大数值。

**说明**：

- $1 \le g.length \le 3 * 10^4$。
- $0 \le s.length \le 3 * 10^4$。
- $1 \le g[i], s[j] \le 2^{31} - 1$。

**示例**：

- 示例 1：

```python
输入：g = [1,2,3], s = [1,1]
输出：1
解释：你有三个孩子和两块小饼干，3 个孩子的胃口值分别是：1, 2, 3。虽然你有两块小饼干，由于他们的尺寸都是 1，你只能让胃口值是 1 的孩子满足。所以应该输出 1。
```

- 示例 2：

```python
输入: g = [1,2], s = [1,2,3]
输出: 2
解释: 你有两个孩子和三块小饼干，2个孩子的胃口值分别是1, 2。你拥有的饼干数量和尺寸都足以让所有孩子满足。所以你应该输出 2。
```

### 1.2 解题思路

#### 思路 1：贪心算法

为了尽可能的满⾜更多的⼩孩，而且一块饼干不能掰成两半，所以我们应该尽量让胃口小的孩子吃小块饼干，这样胃口大的孩子才有大块饼干吃。

所以，从贪心算法的角度来考虑，我们应该按照孩子的胃口从小到大对数组 `g` 进行排序，然后按照饼干的尺寸大小从小到大对数组 `s` 进行排序，并且对于每个孩子，应该选择满足这个孩子的胃口且尺寸最小的饼干。

下面我们使用贪心算法三步走的方法解决这道题。

1. **转换问题**：将原问题转变为，当胃口最小的孩子选择完满足这个孩子的胃口且尺寸最小的饼干之后，再解决剩下孩子的选择问题（子问题）。
2. **贪心选择性质**：对于当前孩子，用尺寸尽可能小的饼干满足这个孩子的胃口。
3. **最优子结构性质**：在上面的贪心策略下，当前孩子的贪心选择 + 剩下孩子的子问题最优解，就是全局最优解。也就是说在贪心选择的方案下，能够使得满足胃口的孩子数量达到最大。

使用贪心算法的代码解决步骤描述如下：

1. 对数组 `g`、`s` 进行从小到大排序，使用变量 `index_g` 和 `index_s` 分别指向 `g`、`s` 初始位置，使用变量 `res` 保存结果，初始化为 `0`。
2. 对比每个元素 `g[index_g]` 和 `s[index_s]`：
   1. 如果 `g[index_g] <= s[index_s]`，说明当前饼干满足当前孩子胃口，则答案数量加 `1`，并且向右移动 `index_g` 和 `index_s`。
   2. 如果 `g[index_g] > s[index_s]`，说明当前饼干无法满足当前孩子胃口，则向右移动 `index_s`，判断下一块饼干是否可以满足当前孩子胃口。
3. 遍历完输出答案 `res`。

#### 思路 1：代码

```python
class Solution:
    def findContentChildren(self, g: List[int], s: List[int]) -> int:
        g.sort()
        s.sort()
        index_g, index_s = 0, 0
        res = 0
        while index_g < len(g) and index_s < len(s):
            if g[index_g] <= s[index_s]:
                res += 1
                index_g += 1
                index_s += 1
            else:
                index_s += 1   

        return res
```

#### 思路 1：复杂度分析

- **时间复杂度**：$O(m \times \log m + n \times \log n)$，其中 $m$ 和 $n$ 分别是数组 $g$ 和 $s$ 的长度。
- **空间复杂度**：$O(\log m + \log n)$。

## 2. [0860. 柠檬水找零](https://leetcode.cn/problems/lemonade-change/)

### 2.1 题目大意

**描述**：一杯柠檬水的售价是 $5$ 美元。现在有 $n$ 个顾客排队购买柠檬水，每人只能购买一杯。顾客支付的钱面额有 $5$ 美元、$10$ 美元、$20$ 美元。必须给每个顾客正确找零（就是每位顾客需要向你支付 $5$ 美元，多出的钱要找还回顾客）。

现在给定 $n$ 个顾客支付的钱币面额数组 `bills`。

**要求**：如果能给每位顾客正确找零，则返回 `True`，否则返回 `False`。

**说明**：

- 一开始的时候手头没有任何零钱。
- $1 \le bills.length \le 10^5$。
- `bills[i]` 不是 $5$ 就是 $10$ 或是 $20$。

**示例**：

- 示例 1：

```python
输入：bills = [5,5,5,10,20]
输出：True
解释：
前 3 位顾客那里，我们按顺序收取 3 张 5 美元的钞票。
第 4 位顾客那里，我们收取一张 10 美元的钞票，并返还 5 美元。
第 5 位顾客那里，我们找还一张 10 美元的钞票和一张 5 美元的钞票。
由于所有客户都得到了正确的找零，所以我们输出 True。
```

- 示例 2：

```python
输入：bills = [5,5,10,10,20]
输出：False
解释：
前 2 位顾客那里，我们按顺序收取 2 张 5 美元的钞票。
对于接下来的 2 位顾客，我们收取一张 10 美元的钞票，然后返还 5 美元。
对于最后一位顾客，我们无法退回 15 美元，因为我们现在只有两张 10 美元的钞票。
由于不是每位顾客都得到了正确的找零，所以答案是 False。
```

### 2.2 解题思路

#### 思路 1：贪心算法

由于顾客只能给我们 $5$、$10$、$20$ 三种面额的钞票，且一开始我们手头没有任何钞票，所以我们手中所能拥有的钞票面额只能是 $5$、$10$、$20$。因此可以采取下面的策略：

1. 如果顾客支付 $5$ 美元，直接收下。
2. 如果顾客支付 $10$ 美元，如果我们手头有 $5$ 美元面额的钞票，则找给顾客，否则无法正确找零，返回 `False`。
3. 如果顾客支付 $20$ 美元，如果我们手头有 $1$ 张 $10$ 美元和 $1$ 张 $5$ 美元的钞票，或者有 $3$ 张 $5$ 美元的钞票，则可以找给顾客。如果两种组合方式同时存在，倾向于第 $1$ 种方式找零，因为使用 $5$ 美元的场景比使用 $10$ 美元的场景多，要尽可能的保留 $5$ 美元的钞票。如果这两种组合方式都不通知，则无法正确找零，返回 `False`。

所以，我们可以使用两个变量 `five` 和 `ten` 来维护手中 $5$ 美元、$10$ 美团的钞票数量， 然后遍历一遍根据上述条件分别判断即可。

#### 思路 1：代码

```python
class Solution:
    def lemonadeChange(self, bills: List[int]) -> bool:
        five, ten, twenty = 0, 0, 0
        for bill in bills:
            if bill == 5:
                five += 1
            if bill == 10:
                if five <= 0:
                    return False
                ten += 1
                five -= 1
            if bill == 20:
                if five > 0 and ten > 0:
                    five -= 1
                    ten -= 1
                    twenty += 1
                elif five >= 3:
                    five -= 3
                    twenty += 1
                else:
                    return False

        return True
```

#### 思路 1：复杂度分析

- **时间复杂度**：$O(n)$，其中 $n$ 是数组 `bill` 的长度。
- **空间复杂度**：$O(1)$。

## 3. [0135. 分发糖果](https://leetcode.cn/problems/candy/)

### 3.1 题目大意

**描述**：$n$ 个孩子站成一排。老师会根据每个孩子的表现，给每个孩子进行评分。然后根据下面的规则给孩子们分发糖果：

- 每个孩子至少得 $1$ 个糖果。
- 评分更高的孩子必须比他两侧相邻位置上的孩子分得更多的糖果。

现在给定 $n$ 个孩子的表现分数数组 `ratings`，其中 `ratings[i]` 表示第 $i$ 个孩子的评分。

**要求**：返回最少需要准备的糖果数目。

**说明**：

- $n == ratings.length$。
- $1 \le n \le 2 \times 10^4$。
- $0 \le ratings[i] \le 2 * 10^4$。

**示例**：

- 示例 1：

```python
输入：ratings = [1,0,2]
输出：5
解释：你可以分别给第一个、第二个、第三个孩子分发 2、1、2 颗糖果。
```

- 示例 2：

```python
输入：ratings = [1,2,2]
输出：4
解释：你可以分别给第一个、第二个、第三个孩子分发 1、2、1 颗糖果。
     第三个孩子只得到 1 颗糖果，这满足题面中的两个条件。
```

### 3.2 解题思路    

#### 思路 1：贪心算法

先来看分发糖果的规则。

「每个孩子至少得 1 个糖果」：说明糖果数目至少为 N 个。

「评分更高的孩子必须比他两侧相邻位置上的孩子分得更多的糖果」：可以看做为以下两种条件：

- 当 $ratings[i - 1] < ratings[i]$ 时，第 i 个孩子的糖果数量比第 $i - 1$ 个孩子的糖果数量多；
- 当 $ratings[i] > ratings[i + 1]$ 时，第 i 个孩子的糖果数量比第$ i + 1$ 个孩子的糖果数量多。

根据以上信息，我们可以设定一个长度为 N 的数组 sweets 来表示每个孩子分得的最少糖果数，初始每个孩子分得糖果数都为 1。

然后遍历两遍数组，第一遍遍历满足当 $ratings[i - 1] < ratings[i]$ 时，第 $i$ 个孩子的糖果数量比第 $i - 1$ 个孩子的糖果数量多 $1$ 个。第二遍遍历满足当 $ratings[i] > ratings[i + 1]$ 时，第 $i$ 个孩子的糖果数量取「第 $i + 1$ 个孩子的糖果数量多 $1$ 个」和「第 $i + 1$ 个孩子目前拥有的糖果数量」中的最大值。

然后再遍历求所有孩子的糖果数量和即为答案。

#### 思路 1：代码

```python
class Solution:
    def candy(self, ratings: List[int]) -> int:
        size = len(ratings)
        sweets = [1 for _ in range(size)]

        for i in range(1, size):
            if ratings[i] > ratings[i - 1]:
                sweets[i] = sweets[i - 1] + 1

        for i in range(size - 2, -1, -1):
            if ratings[i] > ratings[i + 1]:
                sweets[i] = max(sweets[i], sweets[i + 1] + 1)

        res = sum(sweets)
        return res
```

#### 思路 1：复杂度分析

- **时间复杂度**：$O(n)$，其中 $n$ 是数组 `ratings` 的长度。
- **空间复杂度**：$O(n)$。
