# 05.04.03 习题解析（第 11 天）

## 1. [0486. 预测赢家](https://leetcode.cn/problems/predict-the-winner/)

### 1.1 题目大意

**描述**：给定搞一个整数数组 $nums$。玩家 $1$ 和玩家 $2$ 基于这个数组设计了一个游戏。

玩家 $1$ 和玩家 $2$ 轮流进行自己的回合，玩家 $1$ 先手。

开始时，两个玩家的初始分值都是 $0$。每一回合，玩家从数组的任意一端取一个数字（即 $nums[0]$ 或 $nums[nums.length - 1]$），取到的数字将会从数组中移除（数组长度减 $1$）。玩家选中的数字将会加到他的得分上。当数组中没有剩余数字可取时，游戏结束。

**要求**：如果玩家 $1$ 能成为赢家，则返回 `True`。否则返回 `False`。如果两个玩家得分相等，同样认为玩家 $1$ 是游戏的赢家，也返回 `True`。假设每个玩家的玩法都会使他的分数最大化。

**说明**：

- $1 \le nums.length \le 20$。
- $0 \le nums[i] \le 10^7$。

**示例**：

- 示例 1：

```python
输入：nums = [1,5,2]
输出：False
解释：一开始，玩家 1 可以从 1 和 2 中进行选择。
如果他选择 2（或者 1 ），那么玩家 2 可以从 1（或者 2 ）和 5 中进行选择。如果玩家 2 选择了 5 ，那么玩家 1 则只剩下 1（或者 2 ）可选。 
所以，玩家 1 的最终分数为 1 + 2 = 3，而玩家 2 为 5 。
因此，玩家 1 永远不会成为赢家，返回 False。
```

- 示例 2：

```python
输入：nums = [1,5,233,7]
输出：True
解释：玩家 1 一开始选择 1 。然后玩家 2 必须从 5 和 7 中进行选择。无论玩家 2 选择了哪个，玩家 1 都可以选择 233 。
最终，玩家 1（234 分）比玩家 2（12 分）获得更多的分数，所以返回 True，表示玩家 1 可以成为赢家。
```

### 1.2 解题思路

## 2. [1547. 切棍子的最小成本](https://leetcode.cn/problems/minimum-cost-to-cut-a-stick/)

### 2.1 题目大意

**描述**：给定一个整数 $n$，代表一根长度为 $n$ 个单位的木根，木棍从 $0 \sim n$ 标记了若干位置。例如，长度为 $6$ 的棍子可以标记如下：

![](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/08/09/statement.jpg)

再给定一个整数数组 $cuts$，其中 $cuts[i]$ 表示需要将棍子切开的位置。

我们可以按照顺序完成切割，也可以根据需要更改切割顺序。

每次切割的成本都是当前要切割的棍子的长度，切棍子的总成本是所有次切割成本的总和。对棍子进行切割将会把一根木棍分成两根较小的木棍（这两根小木棍的长度和就是切割前木棍的长度）。

**要求**：返回切棍子的最小总成本。

**说明**：

- $2 \le n \le 10^6$。
- $1 \le cuts.length \le min(n - 1, 100)$。
- $1 \le cuts[i] \le n - 1$。
- $cuts$ 数组中的所有整数都互不相同。

**示例**：

- 示例 1：

![](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/08/09/e1.jpg)

```python
输入：n = 7, cuts = [1,3,4,5]
输出：16
解释：按 [1, 3, 4, 5] 的顺序切割的情况如下所示。
第一次切割长度为 7 的棍子，成本为 7 。第二次切割长度为 6 的棍子（即第一次切割得到的第二根棍子），第三次切割为长度 4 的棍子，最后切割长度为 3 的棍子。总成本为 7 + 6 + 4 + 3 = 20 。而将切割顺序重新排列为 [3, 5, 1, 4] 后，总成本 = 16（如示例图中 7 + 4 + 3 + 2 = 16）。
```

![](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/08/09/e11.jpg)

- 示例 2：

```python
输入：n = 9, cuts = [5,6,1,4,2]
输出：22
解释：如果按给定的顺序切割，则总成本为 25。总成本 <= 25 的切割顺序很多，例如，[4, 6, 5, 2, 1] 的总成本 = 22，是所有可能方案中成本最小的。
```

### 2.2 解题思路

#### 思路 1：动态规划

我们可以预先在数组 $cuts$ 种添加位置 $0$ 和位置 $n$，然后对数组 $cuts$ 进行排序。这样待切割的木棍就对应了数组中连续元素构成的「区间」。

###### 1. 划分阶段

按照区间长度进行阶段划分。

###### 2. 定义状态

定义状态 $dp[i][j]$ 表示为：切割区间为 $[i, j]$ 上的小木棍的最小成本。

###### 3. 状态转移方程

假设位置 $i$ 与位置 $j$ 之间最后一个切割的位置为 $k$，则 $dp[i][j]$ 取决与由 $k$ 作为切割点分割出的两个区间 $[i, k]$ 与 $[k, j]$ 上的最小成本 + 切割位置 $k$ 所带来的成本。

而切割位置 $k$ 所带来的成本是这段区间所代表的小木棍的长度，即 $cuts[j] - cuts[i]$。

则状态转移方程为：$dp[i][j] = min \lbrace dp[i][k] + dp[k][j] + cuts[j] - cuts[i] \rbrace, \quad i < k < j$

###### 4. 初始条件

- 相邻位置之间没有切割点，不需要切割，最小成本为 $0$，即 $dp[i - 1][i] = 0$。
- 其余位置默认为最小成本为一个极大值，即 $dp[i][j] = \infty, \quad i + 1 \ne j$。

###### 5. 最终结果

根据我们之前定义的状态，$dp[i][j]$ 表示为：切割区间为 $[i, j]$ 上的小木棍的最小成本。 所以最终结果为 $dp[0][size - 1]$。

#### 思路 1：代码

```python
class Solution:
    def minCost(self, n: int, cuts: List[int]) -> int:
        cuts.append(0)
        cuts.append(n)
        cuts.sort()
        
        size = len(cuts)
        dp = [[float('inf') for _ in range(size)] for _ in range(size)]
        for i in range(1, size):
            dp[i - 1][i] = 0

        for l in range(3, size + 1):        # 枚举区间长度
            for i in range(size):           # 枚举区间起点
                j = i + l - 1               # 根据起点和长度得到终点                            
                if j >= size:      
                    continue
                dp[i][j] = float('inf')
                for k in range(i + 1, j):   # 枚举区间分割点
                    # 状态转移方程，计算合并区间后的最优值
                    dp[i][j] = min(dp[i][j], dp[i][k] + dp[k][j] + cuts[j] - cuts[i])
        return dp[0][size - 1]
```

#### 思路 1：复杂度分析

- **时间复杂度**：$O(m^3)$，其中 $m$ 为数组 $cuts$ 的元素个数。
- **空间复杂度**：$O(m^2)$。

## 3. [0664. 奇怪的打印机](https://leetcode.cn/problems/strange-printer/)

### 3.1 题目大意

**描述**：有一台奇怪的打印机，有以下两个功能：

1. 打印机每次只能打印由同一个字符组成的序列，比如：`"aaaa"`、`"bbb"`。
2. 每次可以从起始位置到结束的任意为止打印新字符，并且会覆盖掉原有字符。

现在给定一个字符串 $s$。

**要求**：计算这个打印机打印出字符串 $s$ 需要的最少打印次数。

**说明**：

- $1 \le s.length \le 100$。
- $s$ 由小写英文字母组成。

**示例**：

- 示例 1：

```python
输入：s = "aaabbb"
输出：2
解释：首先打印 "aaa" 然后打印 "bbb"。
```

- 示例 2：

```python
输入：s = "aba"
输出：2
解释：首先打印 "aaa" 然后在第二个位置打印 "b" 覆盖掉原来的字符 'a'。
```

### 3.2 解题思路    

对于字符串 $s$，我们可以先考虑区间 $[i, j]$ 上的子字符串需要的最少打印次数。

1. 如果区间 $[i, j]$ 内只有 $1$ 种字符，则最少打印次数为 $1$，即：$dp[i][i] = 1$。
2. 如果区间 $[i, j]$ 内首尾字符相同，即 $s[i] == s[j]$，则我们在打印 $s[i]$ 的同时我们可以顺便打印 $s[j]$，这样我们可以忽略 $s[j]$，只考虑剩下区间 $[i, j - 1]$ 的打印情况，即：$dp[i][j] = dp[i][j - 1]$。
3. 如果区间 $[i, j]$ 上首尾字符不同，即 $s[i] \ne s[j]$，则枚举分割点 $k$，将区间 $[i, j]$ 分为区间 $[i, k]$ 与区间 $[k + 1, j]$，使得 $dp[i][k] + dp[k + 1][j]$ 的值最小即为 $dp[i][j]$。

#### 思路 1：动态规划

###### 1. 划分阶段

按照区间长度进行阶段划分。

###### 2. 定义状态

定义状态 $dp[i][j]$ 表示为：打印第 $i$ 个字符到第 $j$ 个字符需要的最少打印次数。

###### 3. 状态转移方程

1. 如果 $s[i] == s[j]$，则我们在打印 $s[i]$ 的同时我们可以顺便打印 $s[j]$，这样我们可以忽略 $s[j]$，只考虑剩下区间 $[i, j - 1]$ 的打印情况，即：$dp[i][j] = dp[i][j - 1]$。
2. 如果 $s[i] \ne s[j]$，则枚举分割点 $k$，将区间 $[i, j]$ 分为区间 $[i, k]$ 与区间 $[k + 1, j]$，使得 $dp[i][k] + dp[k + 1][j]$ 的值最小即为 $dp[i][j]$，即：$dp[i][j] = min(dp[i][j], dp[i][k] + dp[k + 1][j])$。

###### 4. 初始条件

- 初始时，打印单个字符的最少打印次数为 $1$，即 $dp[i][i] = 1$。

###### 5. 最终结果

根据我们之前定义的状态，$dp[i][j]$ 表示为：打印第 $i$ 个字符到第 $j$ 个字符需要的最少打印次数。 所以最终结果为 $dp[0][size - 1]$。

#### 思路 1：代码

```python
class Solution:
    def strangePrinter(self, s: str) -> int:
        size = len(s)
        dp = [[float('inf') for _ in range(size)] for _ in range(size)]
        for i in range(size):
            dp[i][i] = 1
            
        for l in range(2, size + 1):
            for i in range(size):
                j = i + l - 1
                if j >= size:
                    break
                if s[i] == s[j]:
                    dp[i][j] = dp[i][j - 1]
                else:
                    for k in range(i, j):
                        dp[i][j] = min(dp[i][j], dp[i][k] + dp[k + 1][j])

        return dp[0][size - 1]
```

#### 思路 1：复杂度分析

- **时间复杂度**：$O(n^3)$，其中 $n$ 为字符串 $s$ 的长度。
- **空间复杂度**：$O(n^2)$。