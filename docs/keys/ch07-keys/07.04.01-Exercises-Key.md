# 07.04.01 习题解析（第 13 天）

## 1. [0121. 买卖股票的最佳时机](https://leetcode.cn/problems/best-time-to-buy-and-sell-stock/)

### 1.1 题目大意

**描述**：给定一个数组 `prices` ，它的第 `i` 个元素 `prices[i]` 表示一支给定股票第 `i` 天的价格。只能选择某一天买入这只股票，并选择在未来的某一个不同的日子卖出该股票。

**要求**：计算出能获取的最大利润。如果你不能获取任何利润，返回 $0$。

**说明**：

- $1 \le prices.length \le 10^5$。
- $0 \le prices[i] \le 10^4$。

**示例**：

- 示例 1：

```python
输入：[7,1,5,3,6,4]
输出：5
解释：在第 2 天（股票价格 = 1）的时候买入，在第 5 天（股票价格 = 6）的时候卖出，最大利润 = 6-1 = 5 。
     注意利润不能是 7-1 = 6, 因为卖出价格需要大于买入价格；同时，你不能在买入前卖出股票。
```

- 示例 2：

```python
输入：prices = [7,6,4,3,1]
输出：0
解释：在这种情况下, 没有交易完成, 所以最大利润为 0。
```

### 1.2 解题思路

最简单的思路当然是两重循环暴力枚举，寻找不同天数下的最大利润。但更好的做法是进行一次遍历，递推求解。

#### 思路 1：递推


1. 设置两个变量 `minprice`（用来记录买入的最小值）、`maxprofit`（用来记录可获取的最大利润）。
2. 从左到右进行遍历数组 `prices`。
3. 如果遇到当前价格比 `minprice` 还要小的，就更新 `minprice`。
4. 如果遇到当前价格大于或者等于 `minprice`，则判断一下以当前价格卖出的话能卖多少，如果比 `maxprofit` 还要大，就更新 `maxprofit`。
5. 最后输出 `maxprofit`。

#### 思路 1：代码

```python
class Solution:
    def maxProfit(self, prices: List[int]) -> int:
        minprice = 10010
        maxprofit = 0
        for price in prices:
            if price < minprice:
                minprice = price
            elif price - minprice > maxprofit:
                maxprofit = price - minprice
        return maxprofit
```

#### 思路 1：复杂度分析

- **时间复杂度**：$O(n)$，其中 $n$ 是数组 `prices` 的元素个数。
- **空间复杂度**：$O(1)$。

## 2. [0122. 买卖股票的最佳时机 II](https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-ii/)

### 2.1 题目大意

**描述**：给定一个整数数组 `prices` ，其中 `prices[i]` 表示某支股票第 `i` 天的价格。在每一天，你可以决定是否购买 / 出售股票。你在任何时候最多只能持有一股股票。你也可以先购买，然后在同一天出售。

**要求**：计算出能获取的最大利润。

**说明**：

- $1 \le prices.length \le 3 * 10^4$。
- $0 \le prices[i] \le 10^4$。

**示例**：

- 示例 1：

```python
输入：prices = [7,1,5,3,6,4]
输出：7
解释：在第 2 天（股票价格 = 1）的时候买入，在第 3 天（股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5 - 1 = 4 。
     随后，在第 4 天（股票价格 = 3）的时候买入，在第 5 天（股票价格 = 6）的时候卖出, 这笔交易所能获得利润 = 6 - 3 = 3 。
     总利润为 4 + 3 = 7。
```

- 示例 2：

```python
输入：prices = [1,2,3,4,5]
输出：4
解释：在第 1 天（股票价格 = 1）的时候买入，在第 5 天 （股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5 - 1 = 4 。
     总利润为 4 。
```

### 2.2 解题思路

#### 思路 1：贪心算法

股票买卖获取利润主要是看差价，必然是低点买入，高点卖出才会赚钱。而要想获取最大利润，就要在跌入谷底的时候买入，在涨到波峰的时候卖出利益才会最大化。所以我们购买股票的策略变为了：

1. 连续跌的时候不买。
2. 跌到最低点买入。
3. 涨到最高点卖出。

在这种策略下，只要计算波峰和谷底的差值即可。而波峰和谷底的差值可以通过两两相减所得的差值来累加计算。

#### 思路 1：代码

```python
class Solution:
    def maxProfit(self, prices: List[int]) -> int:
        ans = 0
        for i in range(1, len(prices)):
            ans += max(0, prices[i]-prices[i-1])
        return ans
```

#### 思路 1：复杂度分析

- **时间复杂度**：$O(n)$，其中 $n$ 是数组 `prices` 的元素个数。
- **空间复杂度**：$O(1)$。

## 3. [0300. 最长递增子序列](https://leetcode.cn/problems/longest-increasing-subsequence/)

### 3.1 题目大意

**描述**：给定一个整数数组 `nums`。

**要求**：找到其中最长严格递增子序列的长度。

**说明**：

- **子序列**：由数组派生而来的序列，删除（或不删除）数组中的元素而不改变其余元素的顺序。例如，`[3,6,2,7]` 是数组 `[0,3,1,6,2,2,7]` 的子序列。
- $1 \le nums.length \le 2500$。
- $-10^4 \le nums[i] \le 10^4$。

**示例**：

- 示例 1：

```python
输入：nums = [10,9,2,5,3,7,101,18]
输出：4
解释：最长递增子序列是 [2,3,7,101]，因此长度为 4。
```

- 示例 2：

```python
输入：nums = [0,1,0,3,2,3]
输出：4
```

#### 3.2 解题思路

### 思路 1：动态规划

###### 1. 划分阶段

按照子序列的结尾位置进行阶段划分。

###### 2. 定义状态

定义状态 `dp[i]` 表示为：以 `nums[i]` 结尾的最长递增子序列长度。

###### 3. 状态转移方程

一个较小的数后边如果出现一个较大的数，则会形成一个更长的递增子序列。

对于满足 `0 <= j < i` 的数组元素 `nums[j]` 和 `nums[i]` 来说：

- 如果 `nums[j] < nums[i]`，则 `nums[i]` 可以接在 `nums[j]` 后面，此时以 `nums[i]` 结尾的最长递增子序列长度会在「以 `nums[j]` 结尾的最长递增子序列长度」的基础上加 `1`，即 `dp[i] = dp[j] + 1`。

- 如果 `nums[j] >= nums[i]`，则 `nums[i]` 不可以接在 `nums[j]` 后面，可以直接跳过。

综上，我们的状态转移方程为：`dp[i] = max(dp[i], dp[j] + 1)`，`0 <= j <= i`，`nums[j] < nums[i]`。

###### 4. 初始条件

默认状态下，把数组中的每个元素都作为长度为 `1` 的递增子序列。即 `dp[i] = 1`。

###### 5. 最终结果

根据我们之前定义的状态，`dp[i]` 表示为：以 `nums[i]` 结尾的最长递增子序列长度。那为了计算出最大的最长递增子序列长度，则需要再遍历一遍 `dp` 数组，求出最大值即为最终结果。

#### 思路 1：动态规划代码

```python
class Solution:
    def lengthOfLIS(self, nums: List[int]) -> int:
        size = len(nums)
        dp = [1 for _ in range(size)]

        for i in range(size):
            for j in range(i):
                if nums[i] > nums[j]:
                    dp[i] = max(dp[i], dp[j] + 1)
        
        return max(dp)
```

#### 思路 1：复杂度分析

- **时间复杂度**：$O(n^2)$。两重循环遍历的时间复杂度是 $O(n^2)$，最后求最大值的时间复杂度是 $O(n)$，所以总体时间复杂度为 $O(n^2)$。
- **空间复杂度**：$O(n)$。用到了一维数组保存状态，所以总体空间复杂度为 $O(n)$。
