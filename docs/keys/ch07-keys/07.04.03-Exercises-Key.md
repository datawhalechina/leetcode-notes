# 07.04.03 习题解析（第 15 天）

## 1. [0062. 不同路径](https://leetcode.cn/problems/unique-paths/)

### 1.1 题目大意

**描述**：给定两个整数 `m` 和 `n`，代表大小为 `m * n` 的棋盘， 一个机器人位于棋盘左上角的位置，机器人每次只能向右、或者向下移动一步。

**要求**：计算出机器人从棋盘左上角到达棋盘右下角一共有多少条不同的路径。

**说明**：

- $1 \le m, n \le 100$。
- 题目数据保证答案小于等于 $2 * 10^9$。

**示例**：

- 示例 1：

```python
输入：m = 3, n = 7
输出：28
```

![](https://assets.leetcode.com/uploads/2018/10/22/robot_maze.png)

- 示例 2：

```python
输入：m = 3, n = 2
输出：3
解释：
从左上角开始，总共有 3 条路径可以到达右下角。
1. 向右 -> 向下 -> 向下
2. 向下 -> 向下 -> 向右
3. 向下 -> 向右 -> 向下
```

### 1.2 解题思路

#### 思路 1：动态规划

###### 1. 划分阶段

按照路径的结尾位置（行位置、列位置组成的二维坐标）进行阶段划分。

###### 2. 定义状态

定义状态 `dp[i][j]` 为：从左上角到达 `(i, j)` 位置的路径数量。

###### 3. 状态转移方程

因为我们每次只能向右、或者向下移动一步，因此想要走到 `(i, j)`，只能从 `(i - 1, j)` 向下走一步走过来；或者从 `(i, j - 1)` 向右走一步走过来。所以可以写出状态转移方程为：`dp[i][j] = dp[i - 1][j] + dp[i][j - 1]`，此时 `i > 0，j > 0`。

###### 4. 初始条件

- 从左上角走到 `(0, 0)` 只有一种方法，即 `dp[0][0] = 1`。
- 第一行元素只有一条路径（即只能通过前一个元素向右走得到），所以 `dp[0][j] = 1`。
- 同理，第一列元素只有一条路径（即只能通过前一个元素向下走得到），所以 `dp[i][0] = 1`。

###### 5. 最终结果

根据状态定义，最终结果为 `dp[m - 1][n - 1]`，即从左上角到达右下角 `(m - 1, n - 1)` 位置的路径数量为 `dp[m - 1][n - 1]`。

#### 思路 1：动态规划代码

```python
class Solution:
    def uniquePaths(self, m: int, n: int) -> int:
        dp = [[0 for _ in range(n)] for _ in range(m)]
        
        for j in range(n):
            dp[0][j] = 1
        for i in range(m):
            dp[i][0] = 1

        for i in range(1, m):
            for j in range(1, n):
                dp[i][j] = dp[i - 1][j] + dp[i][j - 1]
        
        return dp[m - 1][n - 1]
```

#### 思路 1：复杂度分析

- **时间复杂度**：$O(m * n)$。初始条件赋值的时间复杂度为 $O(m + n)$，两重循环遍历的时间复杂度为 $O(m * n)$，所以总体时间复杂度为 $O(m * n)$。
- **空间复杂度**：$O(m * n)$。用到了二维数组保存状态，所以总体空间复杂度为 $O(m * n)$。因为 `dp[i][j]` 的状态只依赖于上方值 `dp[i - 1][j]` 和左侧值 `dp[i][j - 1]`，而我们在进行遍历时的顺序刚好是从上至下、从左到右。所以我们可以使用长度为 `m` 的一维数组来保存状态，从而将空间复杂度优化到 $O(m)$。

## 2. [0152. 乘积最大子数组](https://leetcode.cn/problems/maximum-product-subarray/)

### 2.1 题目大意

**描述**：给定一个整数数组 `nums`。

**要求**：找出数组中乘积最大的连续子数组（最少包含一个数字），并返回该子数组对应的乘积。

**说明**：

- 测试用例的答案是一个 32-位整数。
- **子数组**：数组的连续子序列。
- $1 \le nums.length \le 2 * 10^4$。
- $-10 \le nums[i] \le 10$。
- `nums` 的任何前缀或后缀的乘积都保证是一个 32-位整数。

**示例**：

- 示例 1：

```python
输入: nums = [2,3,-2,4]
输出: 6
解释: 子数组 [2,3] 有最大乘积 6。
```

- 示例 2：

```python
输入: nums = [-2,0,-1]
输出: 0
解释: 结果不能为 2, 因为 [-2,-1] 不是子数组。
```

### 2.2 解题思路

#### 思路 1：动态规划

这道题跟「[0053. 最大子序和](https://leetcode.cn/problems/maximum-subarray/)」有点相似，不过一个求的是和的最大值，这道题求解的是乘积的最大值。

乘积有个特殊情况，两个正数、两个负数相乘都会得到正数。所以求解的时候需要考虑负数的情况。

若想要最终的乘积最大，则应该使子数组中的正数元素尽可能的大，负数元素尽可能的小。所以我们可以维护一个最大值变量和最小值变量。

###### 1. 划分阶段

按照子数组的结尾位置进行阶段划分。

###### 2. 定义状态

定义状态 `dp_max[i]` 为：以第 $i$ 个元素结尾的乘积最大子数组的乘积。

定义状态 `dp_min[i]` 为：以第 $i$ 个元素结尾的乘积最小子数组的乘积。

###### 3. 状态转移方程

- `dp_max[i] = max(dp_max[i - 1] * nums[i], nums[i], dp_min[i - 1] * nums[i])`
- `dp_min[i] = min(dp_min[i - 1] * nums[i], nums[i], dp_max[i - 1] * nums[i])`

###### 4. 初始条件

- 以第 $0$ 个元素结尾的乘积最大子数组的乘积为 `nums[0]`，即 `dp_max[0] = nums[0]`。
- 以第 $0$ 个元素结尾的乘积最小子数组的乘积为 `nums[0]`，即 `dp_min[0] = nums[0]`。

###### 5. 最终结果

根据状态定义，最终结果为 $dp_{max}$ 中最大值，即乘积最大子数组的乘积。

#### 思路 1：代码

```python
class Solution:
    def maxProduct(self, nums: List[int]) -> int:
        size = len(nums)
        dp_max = [0 for _ in range(size)]
        dp_min = [0 for _ in range(size)]
        dp_max[0] = nums[0]
        dp_min[0] = nums[0]
        ans = nums[0]
        for i in range(1, size):
            dp_max[i] = max(dp_max[i - 1] * nums[i], nums[i], dp_min[i - 1] * nums[i])
            dp_min[i] = min(dp_min[i - 1] * nums[i], nums[i], dp_max[i - 1] * nums[i])
        return max(dp_max)
```

#### 思路 1：复杂度分析

- **时间复杂度**：$O(n)$，其中 $n$ 为整数数组 `nums` 的元素个数。
- **空间复杂度**：$O(n)$。

#### 思路 2：动态规划 + 滚动优化

因为状态转移方程中只涉及到当前元素和前一个元素，所以我们也可以不使用数组，只使用两个变量来维护 $dp_{max}[i]$ 和 $dp_{min}[i]$。

#### 思路 2：代码

```python
class Solution:
    def maxProduct(self, nums: List[int]) -> int:
        size = len(nums)
        max_num, min_num = nums[0], nums[0]
        ans = nums[0]
        for i in range(1, size):
            temp_max = max_num
            temp_min = min_num
            max_num = max(temp_max * nums[i], nums[i], temp_min * nums[i])
            min_num = min(temp_min * nums[i], nums[i], temp_max * nums[i])
            ans = max(max_num, ans)
        return ans
```

#### 思路 2：复杂度分析

- **时间复杂度**：$O(n)$，其中 $n$ 为整数数组 `nums` 的元素个数。
- **空间复杂度**：$O(1)$。

## 3. [0198. 打家劫舍](https://leetcode.cn/problems/house-robber/)

### 3.1 题目大意

**描述**：给定一个数组 `nums`，`nums[i]` 代表第 `i` 间房屋存放的金额。相邻的房屋装有防盗系统，假如相邻的两间房屋同时被偷，系统就会报警。

**要求**：假如你是一名专业的小偷，计算在不触动警报装置的情况下，一夜之内能够偷窃到的最高金额。

**说明**：

- $1 \le nums.length \le 100$。
- $0 \le nums[i] \le 400$。

**示例**：

- 示例 1：

```python
输入：[1,2,3,1]
输出：4
解释：偷窃 1 号房屋 (金额 = 1) ，然后偷窃 3 号房屋 (金额 = 3)。
     偷窃到的最高金额 = 1 + 3 = 4。
```

- 示例 2：

```python
输入：[2,7,9,3,1]
输出：12
解释：偷窃 1 号房屋 (金额 = 2), 偷窃 3 号房屋 (金额 = 9)，接着偷窃 5 号房屋 (金额 = 1)。
     偷窃到的最高金额 = 2 + 9 + 1 = 12。
```

### 3.2 解题思路

#### 思路 1：动态规划

###### 1. 划分阶段

按照房屋序号进行阶段划分。

###### 2. 定义状态

定义状态 `dp[i]` 表示为：前 `i` 间房屋所能偷窃到的最高金额。

###### 3. 状态转移方程

如果房屋数大于等于 `3` 间，则偷窃第 `i` 间房屋的时候，就有两种状态：

- 偷窃第 `i` 间房屋，那么第 `i - 1` 间房屋就不能偷窃了，偷窃的最高金额为：前 `i - 2` 间房屋的最高总金额 + 第 `i` 间房屋的金额，即 `dp[i] = dp[i - 2] + nums[i]`；
- 不偷窃第 `i` 间房屋，那么第 `i - 1` 间房屋可以偷窃，偷窃的最高金额为：前 `i - 1` 间房屋的最高总金额，即 `dp[i] = dp[i - 1]`。

然后这两种状态取最大值即可，即状态转移方程为：`dp[i] = max(dp[i - 2] + nums[i], dp[i - 1])`，`i > 2` 时。

###### 4. 初始条件

- 如果只有一间房，则直接偷这间屋子就能偷到最高金额，即 `dp[0] = nums[i]`。
- 如果只有两间房，那么就选择金额最大的那间屋进行偷窃，就可以偷到最高金额，即 `dp[1] = max(nums[0], nums[1])`。

###### 5. 最终结果

根据我们之前定义的状态，`dp[i]` 表示为：前 `i` 间房屋所能偷窃到的最高金额。则最终结果为 `dp[size - 1]`，`size` 为总的房屋数。

#### 思路 1：代码

```python
class Solution:
    def rob(self, nums: List[int]) -> int:
        size = len(nums)
        if size == 1:
            return nums[0]
        if size == 2:
            return max(nums[0], nums[1])
        
        dp = [0 for _ in range(size)]
        dp[0] = nums[0]
        dp[1] = max(nums[0], nums[1])
        
        for i in range(2, size):
            dp[i] = max(dp[i - 2] + nums[i], dp[i - 1])

        return dp[size - 1]
```

#### 思路 1：复杂度分析

- **时间复杂度**：$O(n)$。一重循环遍历的时间复杂度为 $O(n)$。
- **空间复杂度**：$O(n)$。用到了一维数组保存状态，所以总体空间复杂度为 $O(n)$。
