# 07.03.02 习题解析（第 10 天）

## 1. [0322. 零钱兑换](https://leetcode.cn/problems/coin-change/)

### 1.1 题目大意

**描述**：给定代表不同面额的硬币数组 `coins` 和一个总金额 `amount`。

**要求**：求出凑成总金额所需的最少的硬币个数。如果无法凑出，则返回 -1。

**说明**：

- $1 \le coins.length \le 12$。
- $1 \le coins[i] \le 2^{31} - 1$。
- $0 \le amount \le 10^4$。

**示例**：

- 示例 1：

```python
输入：coins = [1, 2, 5], amount = 11
输出：3 
解释：11 = 5 + 5 + 1
```

- 示例 2：

```python
输入：coins = [2], amount = 3
输出：-1
```

### 1.2 解题思路

#### 思路 1：广度优先搜索

我们可以从 `amount` 开始，每次从 `coins` 的硬币中选中 `1` 枚硬币，并记录当前挑选硬币的次数。则最快减到 `0` 的次数就是凑成总金额所需的最少的硬币个数。这道题就变成了从 `amount` 减到 `0` 的最短路径问题。我们可以用广度优先搜索的方法来做。

1. 定义 `visited` 为标记已访问值的 set 集合变量，`queue` 为存放值的队列。
2. 将`amount` 状态标记为访问，并将其加入队列 `queue`。
3. 令当前步数加 `1`，然后将当前队列中的所有值依次出队，并遍历硬币数组：
   1. 如果当前值等于当前硬币值，则说明当前硬币刚好能凑成当前值，则直接返回当前次数。
   2. 如果当前值大于当前硬币值，并且当前值减去当前硬币值的差值没有出现在已访问集合 `visited` 中，则将差值添加到队列和访问集合中。

4. 重复执行第 3 步，直到队列为空。
5. 如果队列为空，也未能减到 `0`，则返回 `-1`。

#### 思路 1：代码

```python
class Solution:
    def coinChange(self, coins: List[int], amount: int) -> int:
        if amount == 0:
            return 0
        
        visited = set([amount])
        queue = collections.deque([amount])

        step = 0
        while queue:
            step += 1
            size = len(queue)
            for _ in range(size):
                cur = queue.popleft()
                for coin in coins:
                    if cur == coin:
                        step += 1
                        return step
                    elif cur > coin and cur - coin not in visited:
                        queue.append(cur - coin)
                        visited.add(cur - coin)
            
        return -1
```

#### 思路 1：复杂度分析

- **时间复杂度**：$O(amount \times size)$。其中 $amount$ 表示总金额，$size$ 表示硬币的种类数。
- **空间复杂度**：$O(amount)$。

#### 思路 2：完全背包问题

可以转换为有 `n` 枚不同的硬币，每种硬币可以无限次使用。凑成总金额为 `amount` 的背包，最少需要多少硬币。

###### 1. 划分阶段

按照子串的起始位置进行阶段划分。

###### 2. 定义状态

定义状态 `dp[i]` 表示为：凑成总金额为 `i` 的最少硬币数量。

###### 3. 状态转移方程

`dp[i]` 来源于两部分：

- 不使用当前硬币，只使用之前硬币凑成金额 `i` 的最少硬币数量。
- 凑成金额 `i - num` 的最少硬币数量，再加上当前硬币。

上述两者的较小值即为 `dp[i]`。

###### 4. 初始条件

- 凑成总金额为 `0` 的最少硬币数量为 `0`，即 `dp[0] = 0`。

###### 5. 最终结果

根据我们之前定义的状态，`dp[i]` 表示为：凑成总金额为 `i` 的最少硬币数量。则最终结果为 `dp[amount]`。

#### 思路 2：代码

```python
class Solution:
    def coinChange(self, coins: List[int], amount: int) -> int:
        dp = [float('inf') for _ in range(amount + 1)]
        dp[0] = 0

        for coin in coins:
            for i in range(coin, amount + 1):
                dp[i] = min(dp[i], dp[i - coin] + 1)

        if dp[amount] != float('inf'):
            return dp[amount]
        else:
            return -1
```

#### 思路 2：复杂度分析

- **时间复杂度**：$O(amount \times size)$。其中 $amount$ 表示总金额，$size$ 表示硬币的种类数。
- **空间复杂度**：$O(amount)$。

## 2. [0078. 子集](https://leetcode.cn/problems/subsets/)

### 2.1 题目大意

**描述**：给定一个整数数组 `nums`，数组中的元素互不相同。

**要求**：返回该数组所有可能的不重复子集。可以按任意顺序返回解集。

**说明**：

- $1 \le nums.length \le 10$。
- $-10 \le nums[i] \le 10$。
- `nums` 中的所有元素互不相同。

**示例**：

- 示例 1：

```python
输入 nums = [1,2,3]
输出 [[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3]]
```

- 示例 2：

```python
输入：nums = [0]
输出：[[],[0]]
```

### 2.2 解题思路

#### 思路 1：回溯算法

数组的每个元素都有两个选择：选与不选。

我们可以通过向当前子集数组中添加可选元素来表示选择该元素。也可以在当前递归结束之后，将之前添加的元素从当前子集数组中移除（也就是回溯）来表示不选择该元素。

下面我们根据回溯算法三步走，写出对应的回溯算法。

1. **明确所有选择**：根据数组中每个位置上的元素选与不选两种选择，画出决策树，如下图所示。

  - ![](../../images/20220425210640.png)

2. **明确终止条件**：

   - 当遍历到决策树的叶子节点时，就终止了。即当前路径搜索到末尾时，递归终止。

3. **将决策树和终止条件翻译成代码：**
   1. 定义回溯函数：

      - `backtracking(nums, index):` 函数的传入参数是 `nums`（可选数组列表）和 `index`（代表当前正在考虑元素是 `nums[i]` ），全局变量是 `res`（存放所有符合条件结果的集合数组）和 `path`（存放当前符合条件的结果）。
      - `backtracking(nums, index):` 函数代表的含义是：在选择 `nums[index]` 的情况下，递归选择剩下的元素。
   2. 书写回溯函数主体（给出选择元素、递归搜索、撤销选择部分）。
      - 从当前正在考虑元素，到数组结束为止，枚举出所有可选的元素。对于每一个可选元素：
        - 约束条件：之前选过的元素不再重复选用。每次从 `index` 位置开始遍历而不是从 `0` 位置开始遍历就是为了避免重复。集合跟全排列不一样，子集中 `{1, 2}` 和 `{2, 1}` 是等价的。为了避免重复，我们之前考虑过的元素，就不再重复考虑了。
        - 选择元素：将其添加到当前子集数组 `path` 中。
        - 递归搜索：在选择该元素的情况下，继续递归考虑下一个位置上的元素。
        - 撤销选择：将该元素从当前子集数组 `path` 中移除。
    ```python
    for i in range(index, len(nums)):   # 枚举可选元素列表
        path.append(nums[i])            # 选择元素
        backtracking(nums, i + 1)       # 递归搜索
        path.pop()                      # 撤销选择
    ```
   
   3. 明确递归终止条件（给出递归终止条件，以及递归终止时的处理方法）。
      - 当遍历到决策树的叶子节点时，就终止了。也就是当正在考虑的元素位置到达数组末尾（即 `start >= len(nums)`）时，递归停止。
      - 从决策树中也可以看出，子集需要存储的答案集合应该包含决策树上所有的节点，应该需要保存递归搜索的所有状态。所以无论是否达到终止条件，我们都应该将当前符合条件的结果放入到集合中。

#### 思路 1：代码

```python
class Solution:
    def subsets(self, nums: List[int]) -> List[List[int]]:
        res = []  # 存放所有符合条件结果的集合
        path = []  # 存放当前符合条件的结果
        def backtracking(nums, index):          # 正在考虑可选元素列表中第 index 个元素
            res.append(path[:])                 # 将当前符合条件的结果放入集合中
            if index >= len(nums):              # 遇到终止条件（本题）
                return

            for i in range(index, len(nums)):   # 枚举可选元素列表
                path.append(nums[i])            # 选择元素
                backtracking(nums, i + 1)       # 递归搜索
                path.pop()                      # 撤销选择

        backtracking(nums, 0)
        return res
```

#### 思路 1：复杂度分析

- **时间复杂度**：$O(n \times 2^n)$，其中 $n$ 指的是数组 `nums` 的元素个数，$2^n$ 指的是所有状态数。每种状态需要 $O(n)$ 的时间来构造子集。
- **空间复杂度**：$O(n)$，每种状态下构造子集需要使用 $O(n)$ 的空间。

#### 思路 2：二进制枚举

对于一个元素个数为 `n` 的集合 `nums`  来说，每一个位置上的元素都有选取和未选取两种状态。我们可以用数字 `1` 来表示选取该元素，用数字 `0` 来表示不选取该元素。

那么我们就可以用一个长度为 `n` 的二进制数来表示集合 `nums` 或者表示 `nums` 的子集。其中二进制的每一位数都对应了集合中某一个元素的选取状态。对于集合中第 `i` 个元素（`i` 从 `0` 开始编号）来说，二进制对应位置上的 `1` 代表该元素被选取，`0` 代表该元素未被选取。

举个例子来说明一下，比如长度为 `5` 的集合 `nums = {5, 4, 3, 2, 1}`，我们可以用一个长度为 `5` 的二进制数来表示该集合。 

比如二进制数 `11111` 就表示选取集合的第 `0` 位、第 `1` 位、第 `2` 位、第 `3` 位、第 `4` 位元素，也就是集合 `{5, 4, 3, 2, 1}` ，即集合 `nums`  本身。如下表所示：

| 集合 nums 对应位置（下标） |  4   |  3   |  2   |  1   |  0   |
| :------------------------- | :--: | :--: | :--: | :--: | :--: |
| 二进制数对应位数           |  1   |  1   |  1   |  1   |  1   |
| 对应选取状态               | 选取 | 选取 | 选取 | 选取 | 选取 |

再比如二进制数 `10101` 就表示选取集合的第 `0` 位、第 `2` 位、第 `5` 位元素，也就是集合 `{5, 3, 1}`。如下表所示：

| 集合 nums 对应位置（下标） |  4   |   3    |  2   |   1    |  0   |
| :------------------------- | :--: | :----: | :--: | :----: | :--: |
| 二进制数对应位数           |  1   |   0    |  1   |   0    |  1   |
| 对应选取状态               | 选取 | 未选取 | 选取 | 未选取 | 选取 |

再比如二进制数 `01001` 就表示选取集合的第 `0` 位、第 `3` 位元素，也就是集合 `{5, 2}`。如下标所示：

| 集合 nums 对应位置（下标） |   4    |  3   |   2    |   1    |  0   |
| :------------------------- | :----: | :--: | :----: | :----: | :--: |
| 二进制数对应位数           |   0    |  1   |   0    |   0    |  1   |
| 对应选取状态               | 未选取 | 选取 | 未选取 | 未选取 | 选取 |

通过上面的例子我们可以得到启发：对于长度为 `5` 的集合 `nums` 来说，我们只需要从 `00000` ~ `11111` 枚举一次（对应十进制为 $0 \sim 2^4 - 1$）即可得到长度为 `5` 的集合 `S` 的所有子集。

我们将上面的例子拓展到长度为 `n` 的集合 `nums`。可以总结为：

- 对于长度为 `5` 的集合 `nums` 来说，只需要枚举 $0 \sim 2^n - 1$（共 $2^n$ 种情况），即可得到所有的子集。

#### 思路 2：代码

```python
class Solution:
    def subsets(self, nums: List[int]) -> List[List[int]]:
        n = len(nums)                       # n 为集合 nums 的元素个数
        sub_sets = []                       # sub_sets 用于保存所有子集
        for i in range(1 << n):             # 枚举 0 ~ 2^n - 1
            sub_set = []                    # sub_set 用于保存当前子集
            for j in range(n):              # 枚举第 i 位元素
                if i >> j & 1:              # 如果第 i 为元素对应二进制位为 1，则表示选取该元素
                    sub_set.append(nums[j]) # 将选取的元素加入到子集 sub_set 中
            sub_sets.append(sub_set)        # 将子集 sub_set 加入到所有子集数组 sub_sets 中
        return sub_sets                     # 返回所有子集
```

#### 思路 2：复杂度分析

- **时间复杂度**：$O(n \times 2^n)$，其中 $n$ 指的是数组 `nums` 的元素个数，$2^n$ 指的是所有状态数。每种状态需要 $O(n)$ 的时间来构造子集。
- **空间复杂度**：$O(n)$，每种状态下构造子集需要使用 $O(n)$ 的空间。

## 3. [0221. 最大正方形](https://leetcode.cn/problems/maximal-square/)

### 3.1 题目大意

**描述**：给定一个由 `'0'` 和 `'1'` 组成的二维矩阵 `matrix`。

**要求**：找到只包含 `'1'` 的最大正方形，并返回其面积。

**说明**：

- $m == matrix.length$。
- $n == matrix[i].length$。
- $1 \le m, n \le 300$。
- `matrix[i][j]` 为 `'0'` 或 `'1'`。

**示例**：

- 示例 1：

![](https://assets.leetcode.com/uploads/2020/11/26/max1grid.jpg)

```python
输入：matrix = [["1","0","1","0","0"],["1","0","1","1","1"],["1","1","1","1","1"],["1","0","0","1","0"]]
输出：4
```

- 示例 2：

![](https://assets.leetcode.com/uploads/2020/11/26/max2grid.jpg)

```python
输入：matrix = [["0","1"],["1","0"]]
输出：1
```

### 3.2 解题思路    

#### 思路 1：动态规划

###### 1. 划分阶段

按照正方形的右下角坐标进行阶段划分。

###### 2. 定义状态

定义状态 `dp[i][j]` 表示为：以矩阵第 `[i, j]` 位置为右下角，且值包含 $1$ 的正方形的最大边长。

###### 3. 状态转移方程

只有当第 $i$ 行、第 $j$ 列位置为 $1$ 时，才有可能存在正方形。

- 如果矩阵第 `[i, j]` 位置为 $0$，则 `dp[i][j] = 0`。
- 如果矩阵第 `[i, j]` 位置为 $1$，则 `dp[i][j]` 的值该位置上方、左侧、左上方三者共同约束的，为三者中最小值加 $1$。即：`dp[i][j] = min(dp[i - 1][j - 1], dp[i - 1][j], dp[i][j - 1]) + 1`。

###### 4. 初始条件

- 凑成总金额为 `0` 的最少硬币数量为 `0`，即 `dp[0] = 0`。

###### 5. 最终结果

根据我们之前定义的状态，`dp[i][j]` 表示为：以矩阵第 `[i, j]` 位置为右下角，且值包含 $1$ 的正方形的最大边长。则最终结果为所有 `dp[i][j]` 中的最大值。

#### 思路 1：代码

```python
class Solution:
    def maximalSquare(self, matrix: List[List[str]]) -> int:
        rows, cols = len(matrix), len(matrix[0])
        max_size = 0
        dp = [[0 for _ in range(cols + 1)] for _ in range(rows + 1)]
        for i in range(rows):
            for j in range(cols):
                if matrix[i][j] == '1':
                    if i == 0 or j == 0:
                        dp[i][j] = 1
                    else:
                        dp[i][j] = min(dp[i - 1][j - 1], dp[i - 1][j], dp[i][j - 1]) + 1
                    max_size = max(max_size, dp[i][j])
        return max_size * max_size
```

#### 思路 1：复杂度分析

- **时间复杂度**：$O(m \times n)$，其中 $m$、$n$ 分别为二维矩阵 `matrix` 的行数和列数。
- **空间复杂度**：$O(m \times n)$。
